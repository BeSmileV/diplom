\subsection{Технологии разработки клиентской части приложения}

Для реализации клиентской части платформы выбраны современные инструменты, обеспечивающие модульность, производительность, типизацию и масштабируемость интерфейса.

\subsubsection{Язык программирования — TypeScript}

JavaScript является одним из самых популярных языков программирования для веб-разработки. Он широко используется для создания динамичных веб-страниц и приложений, поскольку позволяет работать с элементами DOM, асинхронно загружать данные и обеспечивать интерактивность пользовательских интерфейсов. Однако JavaScript имеет важный недостаток — отсутствие статической типизации. Это означает, что переменные и функции не привязываются к определённым типам данных, что может привести к ошибкам на этапе выполнения, которые трудно обнаружить в процессе разработки. Особенно это может быть проблемой в крупных приложениях, где сложно отслеживать все возможные типы данных и их изменения.

Для устранения этих проблем был разработан язык TypeScript, являющийся надмножеством JavaScript. TypeScript добавляет в JavaScript статическую типизацию, что позволяет разработчикам явно указывать типы данных для переменных и функций. Это значительно снижает вероятность ошибок и улучшает поддержку кода в будущем. Благодаря строгой типизации TypeScript помогает предотвращать баги, связанные с динамическими типами в JavaScript, и улучшает автозаполнение в редакторах кода. TypeScript распространяется как библиотека, которую можно интегрировать в проекты на JavaScript, обеспечивая совместимость с существующим кодом и позволяя постепенно внедрять типизацию без необходимости переписывать весь проект. Это особенно важно в крупных и масштабируемых приложениях, где несколько разработчиков работают с общими компонентами, и типизация помогает поддерживать консистентность кода на протяжении всего проекта. Для получения большей информации смотрите документацию~~\cite{typescript_handbook}.

\subsubsection{Библиотека — React}

React — библиотека для построения пользовательских интерфейсов, разработанная Facebook (см. документацию~\cite{react_getting_started}). Она широко используется в веб-разработке благодаря своей простоте, гибкости и высокой производительности. React обеспечивает декларативный стиль программирования, при котором разработчик описывает, как должен выглядеть интерфейс при заданном состоянии, а библиотека самостоятельно обновляет DOM при изменениях. Это упрощает разработку сложных и динамичных интерфейсов.

Можно выделить следующие ключевые особенности:
\begin{itemize}
  \item Компонентный подход: Приложение разбивается на переиспользуемые и изолированные компоненты;
  \item JSX-синтаксис: Комбинация JavaScript и разметки, упрощающая написание UI;
  \item Virtual DOM: Эффективное обновление только изменённых элементов страницы;
  \item Hooks API: Современный способ управления состоянием и побочными эффектами.
\end{itemize}

Преимущества для образовательных платформ:
\begin{itemize}
  \item Быстрая разработка за счёт декларативности и компонентного подхода;
  \item Большое сообщество и развитая экосистема (Next.js, Redux, React Query и др.);
  \item Поддержка SSR и SSG при использовании Next.js;
  \item Простая интеграция с библиотеками и сторонними сервисами.
\end{itemize}

Ограничения:
\begin{itemize}
  \item Отсутствие встроенной архитектуры — требует выбора и настройки дополнительных инструментов;
  \item Более низкий порог входа может привести к «разнообразию» архитектурных подходов в команде;
  \item Без Next.js не включаются такие возможности, как маршрутизация, SSR и API.
\end{itemize}

\subsubsection{Веб-фреймворк — Angular}
Angular — полноценный MVC-фреймворк, предоставляющий комплексное решение для разработки enterprise-приложений~\cite{angular_overview}. В отличие от React, Angular накладывает строгую архитектурную модель, что обеспечивает единообразие кодовой базы в крупных проектах.

Ключевые особенности:
\begin{itemize}
  \item Двустороннее связывание данных: Автоматическая синхронизация между моделью и представлением;
  \item Инъекция зависимостей: Встроенный механизм для управления сервисами и их зависимостями~\cite{angular_dependency_injection};
  \item CLI-инструменты: Генерация компонентов, сервисов и модулей через командную строку;
  \item TypeScript-first: Полная поддержка статической типизации «из коробки».
\end{itemize}

Преимущества для образовательных платформ:
\begin{itemize}
  \item Строгая структура проекта для командной разработки;
  \item Встроенная поддержка форм с валидацией;
  \item Готовые решения для маршрутизации и HTTP-клиента.
\end{itemize}

Ограничения:
\begin{itemize}
  \item Высокий порог входа из-за сложной терминологии (декораторы, зоны, сервисы);
  \item Большой размер бандла (до 500 КБ в минимальной сборке);
  \item Жёсткие требования к архитектуре.
\end{itemize}

\subsubsection{Прогрессивный веб-фреймворк — Vue.js}
Vue.js — прогрессивный фреймворк, сочетающий подходы React и Angular~\cite{vuejs_guide}. Особенно эффективен для быстрого прототипирования и проектов средней сложности.

Основные характеристики:
\begin{itemize}
  \item Реактивная система: Автоматическое отслеживание зависимостей данных;
  \item Гибкая интеграция: Возможность использования как через CDN, так и в составе сложных SPA;
  \item Single-File Components: Объединение шаблона, логики и стилей в одном \textit{.vue}-файле;
  \item Переходные анимации: Встроенная поддержка анимации состояний.
\end{itemize}

Сильные стороны для учебных проектов:
\begin{itemize}
  \item Понятная документация с интерактивными примерами;
  \item Мягкая кривая обучения для начинающих;
  \item Компактный размер ядра (24 КБ в gzip).
\end{itemize}

Ограничения:
\begin{itemize}
  \item Относительно небольшое сообщество по сравнению с React/Angular;
  \item Ограниченные возможности SSR без Nuxt.js;
  \item Меньший выбор готовых UI-библиотек.
\end{itemize}

\subsubsection{Сравнительный анализ фреймворков}

На основе сравнения характеристик трёх популярных JavaScript-фреймворков (см. таблицу~\ref{tab:framework-comparison}) можно сделать следующие выводы: React с Next.js демонстрирует высокую производительность и даёт гибкую архитектуру, а встроенная поддержка SSR/SSG и SEO-оптимизация делают этот стек идеальным выбором для масштабируемых образовательных приложений. Angular, с другой стороны, благодаря строгой типизации и продуманной структуре, подходит для крупных enterprise-систем, где важны единообразие и безопасность кода. Vue.js сочетает в себе простоту освоения и возможность расширения экосистемы, что отлично для быстрого запуска MVP и небольших команд.

\begin{table}[h]
  \small
  \centering
  \caption{Сравнение характеристик фреймворков}
  \label{tab:framework-comparison}
  \begin{tabular}{|l|c|c|c|}
    \hline
    \textbf{Параметр}         & React + Next.js       & Angular       & Vue.js   \\ \hline
    Кривая обучения           & Средняя               & Высокая       & Средняя  \\ \hline
    Сообщество                & Крупное               & Крупное       & Растущее \\ \hline
    Производительность        & Высокая               & Средняя       & Высокая  \\ \hline
    Гибкость архитектуры      & Высокая               & Минимальная   & Средняя  \\ \hline
    Поддержка SSR             & Встроенная (Next.js)  & Встроенная    & Nuxt.js  \\ \hline
    Поддержка TypeScript      & Да                    & Да            & Да       \\ \hline
    Готовая маршрутизация     & Да (Next.js)          & Да            & Да (Vue Router) \\ \hline
  \end{tabular}
\end{table}

\subsubsection*{Фреймворк SSR/SSG — Next.js}

Фреймворк для React объединяет в себе серверный рендеринг и «гидратацию» клиентского кода, обеспечивая быструю и плавную работу приложений. Благодаря гидратации браузеру отправляется только необходимый на текущий момент минимальный объём JavaScript, а по мере навигации и взаимодействия фреймворк автоматически подгружает дополнительные скрипты, расширяя уже отрендеренный контент. Это снижает время первого отображения страницы и ускоряет переходы между разделами, что особенно важно для крупных проектов с большими бандлами.

В документации~\cite{nextjs_ssr} выделяют несколько режимов серверного рендеринга:
\begin{itemize}
  \item SSR (Server-Side Rendering) — классический серверный рендеринг, при котором HTML-страница полностью генерируется на сервере при каждом запросе и отправляется клиенту. Пользователь сразу видит готовый контент без ожидания выполнения JavaScript.
  \item SSG (Static Site Generation) — статическая генерация страниц на этапе билда проекта: все HTML-файлы готовятся заранее и хранятся на сервере, что позволяет отдавать их мгновенно и без лишних вычислений~\cite{nextjs_ssg_isr}.
  \item ISR (Incremental Static Regeneration) — расширение SSG, дающее возможность автоматически пересобирать отдельные страницы через заданные интервалы времени, сохраняя преимущества статической отдачи и обновляя устаревший контент~\cite{nextjs_ssg_isr}.
\end{itemize}

Такой многообразный набор инструментов делает Next.js крайне гибким: разработчики могут подобрать оптимальный способ рендеринга для каждой страницы --- от полностью статических лендингов до динамических разделов с актуальными данными. В результате ваше приложение получает высокую производительность, хорошую индексацию поисковиками и комфортный пользовательский опыт без избыточной передачи данных.

\subsubsection*{Библиотека WebSocket — Socket.IO}

JavaScript-библиотека Socket.IO с открытым исходным кодом предназначена для реализации двустороннего взаимодействия между клиентом и сервером в режиме реального времени. В соответствии с документацией~\cite{socketio_docs} особенностью данной технологии является использование собственного протокола поверх WebSocket с возможностью автоматического переключения на альтернативные методы связи (long polling и др.) при отсутствии поддержки WebSocket.

Преимущества использования Socket.IO:
\begin{itemize}
  \item Гибкость: Разработчики имеют полный контроль над архитектурой соединения, включая маршрутизацию сообщений, обработку событий, систему комнат (rooms) и пространств имён (namespaces);
  \item Масштабируемость: Поддержка кластеризации и горизонтального масштабирования при помощи Redis-адаптеров;
  \item Совместимость с Node.js: Socket.IO органично интегрируется в стек на основе Node.js, что упрощает реализацию единой инфраструктуры;
  \item Производительность: Низкая задержка при передаче сообщений благодаря постоянному соединению между клиентом и сервером;
  \item Интеграция с Python: Для серверной части на Python существует аналогичная библиотека \textit{python-socketio}, которая позволяет использовать те же возможности для реализации чатов и двустороннего общения между клиентом и сервером.
\end{itemize}

Недостатки:
\begin{itemize}
  \item Необходимость разработки и поддержки собственной серверной инфраструктуры;
  \item Повышенная сложность при масштабировании без использования внешних инструментов (Redis, Kubernetes);
  \item Отсутствие встроенной панели мониторинга или аналитики соединений.
\end{itemize}

\subsubsection*{Сервис обмена событиями в реальном времени — Pusher}

Pusher — это облачная платформа, предоставляющая API и SDK для реализации push-уведомлений и двусторонней передачи данных в реальном времени~\cite{pusher_docs}. В отличие от Socket.IO, Pusher представляет собой managed-сервис, абстрагирующий низкоуровневые детали инфраструктуры.

Преимущества использования Pusher:
\begin{itemize}
  \item Упрощённая интеграция: SDK и готовые клиентские библиотеки позволяют быстро настроить соединение и передавать события;
  \item Масштабируемость: Обеспечивается на уровне платформы без участия разработчика;
  \item Надёжность: Pusher использует устойчивую облачную инфраструктуру с балансировкой нагрузки;
  \item Аналитика и мониторинг: Панель управления предоставляет данные о соединениях, событиях и каналах.
\end{itemize}

Ограничения:
\begin{itemize}
  \item Платная модель: Бесплатный тариф ограничен по числу соединений и событий, что делает использование невыгодным при росте нагрузки;
  \item Зависимость от стороннего сервиса: Потенциальные риски, связанные с отказоустойчивостью внешнего провайдера;
  \item Ограниченная кастомизация: Структура событий и поведения определяется особенностями платформы.
\end{itemize}

\subsubsection*{Двунаправленный обмен сообщениями — WebSocket в JavaScript}

JavaScript предоставляет встроенный класс \textit{WebSocket} для организации двустороннего обмена данными между клиентом и сервером~\cite{mdn_websocket_api}. Этот класс реализует базовую функциональность протокола WebSocket, предоставляя разработчикам простой способ обмена данными в реальном времени без необходимости использовать сторонние библиотеки. Однако, несмотря на свою доступность, использование \textit{WebSocket} требует значительных усилий для реализации различных важных аспектов взаимодействия.

К примеру, при использовании \textit{WebSocket} разработчик должен самостоятельно реализовать:
\begin{itemize}
  \item переподключение сокета при его падении;
  \item буферизацию сообщений в случае разрыва соединения;
  \item обработку таймаутов и ошибок;
  \item поддержку различных сред (например, Node.js и браузер);
  \item масштабирование на сервере.
\end{itemize}

Таким образом, несмотря на его доступность и гибкость, использование \textit{WebSocket} требует написания значительного объёма дополнительной логики. Это делает его менее удобным для быстрого внедрения в проект, особенно в случае масштабируемых приложений.

С учётом всех этих факторов было принято решение отказаться от использования низкоуровневого \textit{WebSocket} в пользу более высокоуровневых решений, таких как \textit{Socket.IO} или \textit{Pusher}, которые предоставляют необходимую функциональность и обрабатывают множество нюансов «из коробки», позволяя сосредоточиться на бизнес-логике приложения.


\subsubsection*{Сравнение и выбор технологии для чатов}

При сравнении библиотек Socket.IO и Pusher необходимо учитывать как технические, так и организационные аспекты. В таблице \ref{tab:chat-comparison} представлено краткое сопоставление ключевых параметров:

\begin{table}[h]
  \centering
  \caption{Сравнение технологий для реализации чатов в реальном времени}
  \small
  \label{tab:chat-comparison}
  \begin{tabular}{|l|p{5cm}|p{5cm}|}
    \hline
    \textbf{Критерий} & \textbf{Socket.IO}               & \textbf{Pusher}                 \\ \hline
    Тип решения      & Open-source библиотека           & Облачный managed-сервис         \\ \hline
    Контроль над     & Полный                           & Ограниченный                    \\ 
    архитектурой     &                                  &                                 \\ \hline
    Поддержка        & Через Redis и кластеризацию      & Встроенная на уровне платформы  \\ \hline
    Простота настройки & Средняя (требует сервера)      & Высокая (SDK)                   \\ \hline
    Затраты на       & Бесплатно                        & Платная модель                  \\ \hline
    Интеграция с     & Нативная                         & Через SDK                       \\ 
    Node.js          &                                  &                                 \\ \hline
    Надёжность       & Высокая                          & Высокая                         \\ \hline
    Кастомизация     & Да                               & Нет                             \\ \hline
  \end{tabular}
\end{table}

С учётом специфики проекта — ограниченного бюджета, необходимости полной кастомизации и тесной интеграции с Node.js-сервером — наилучшим выбором является использование Socket.IO. Данная библиотека предоставляет все необходимые механизмы для реализации масштабируемой и надёжной чат-системы, при этом позволяя оптимизировать производительность без привлечения сторонних сервисов.

Более того, благодаря открытому коду Socket.IO не ограничивает разработчика в выборе архитектурных решений, а также обеспечивает возможность расширения функционала в будущем. В условиях ограниченных ресурсов образовательной платформы такой подход оказывается наиболее целесообразным.

\subsubsection*{Библиотека аутентификации — Auth.js}

Auth.js — это библиотека для реализации аутентификации и авторизации в веб-приложениях. Она является официальным решением, рекомендуемым и поддерживаемым фреймворком Next.js, что гарантирует хорошую интеграцию и поддержку всех необходимых функций. Библиотека позволяет легко подключать сторонние провайдеры аутентификации, такие как Google, Facebook и другие (см.~\cite{nextauth_docs}), а также реализовывать собственную аутентификацию с использованием базы данных. Auth.js обеспечивает надёжную защиту пользовательских данных, управление сессиями, работу с токенами и предоставляет удобные API для быстрой настройки. Это решение упрощает реализацию всех ключевых механизмов безопасности, освобождая разработчиков от необходимости погружаться в тонкости реализации.  

\subsubsection*{Библиотека управления состоянием приложения — Redux}

Redux — это библиотека для управления состоянием в приложениях, основанных на React ~\cite{redux_docs}. Она используется для централизованного хранения состояния приложения, что облегчает обмен данными между компонентами и упрощает их взаимодействие. Redux помогает избежать «проблемы пропс-дерева» в больших приложениях, когда передача данных через множество вложенных компонентов становится сложной. Хотя Redux часто используется в более сложных приложениях, в данном проекте его роль заключается в том, чтобы сделать взаимодействие между компонентами более организованным и простым.

