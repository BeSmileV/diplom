\subsection{Технологии разработки клиентской части приложения}

Для реализации клиентской части платформы выбраны современные инструменты, обеспечивающие модульность, производительность, типизацию и масштабируемость интерфейса.

\subsubsection{Язык программирования TypeScript}

JavaScript является одним из самых популярных языков программирования для веб-разработки. Он широко используется для создания динамичных веб-страниц и приложений, поскольку позволяет работать с элементами DOM-дерева (представление HTML-документа в виде дерева тегов), асинхронно загружать данные и обеспечивать интерактивность пользовательских интерфейсов. Однако JavaScript имеет важный недостаток — отсутствие статической типизации. Это означает, что переменные и функции не привязываются к определённым типам данных, что может привести к ошибкам на этапе выполнения, которые трудно обнаружить в процессе разработки. Особенно это может быть проблемой в крупных приложениях, где сложно отслеживать все возможные типы данных и их изменения.

Для устранения этих проблем был разработан язык TypeScript, являющийся надмножеством JavaScript.Язык программирования TypeScript добавляет в JavaScript статическую типизацию, что позволяет разработчикам явно указывать типы данных для переменных и функций. Это значительно снижает вероятность ошибок и улучшает поддержку приложения в будущем. Благодаря строгой типизации язык программирования TypeScript помогает предотвращать баги, связанные с динамическими типами в языке программирования JavaScript, и улучшает автозаполнение в редакторах текста программы. Язык программирования TypeScript распространяется как библиотека, которую можно интегрировать в проекты на языке JavaScript, обеспечивая совместимость с существующим приложением и позволяя постепенно внедрять типизацию без необходимости переписывать весь проект. Это особенно важно в крупных и масштабируемых приложениях, где несколько разработчиков работают с общими компонентами, и типизация помогает поддерживать консистентность текста программы на протяжении всего проекта. Для получения большей информации смотрите документацию~\cite{typescript_handbook}.

\subsubsection{Библиотека React}

React — библиотека для построения пользовательских интерфейсов, разработанная Facebook (см. документацию~\cite{react_getting_started}). Она широко используется в веб-разработке благодаря своей простоте, гибкости и высокой производительности.Библиотека React обеспечивает декларативный стиль программирования, при котором разработчик описывает, как должен выглядеть интерфейс при заданном состоянии, а библиотека самостоятельно обновляет DOM-дерево при изменениях. Это упрощает разработку сложных и динамичных интерфейсов.

Можно выделить следующие ключевые особенности
\begin{enumerate}
  \item Приложение разбивается на переиспользуемые и изолированные компоненты, что отражает компонентный подход;
  \item JSX-синтаксис объединяет синтаксисы языка JavaScript и HTML-разметки, упрощая написание пользовательского интерфейса;
  \item Использование виртуального дерева компонентов позволяет эффективно обновлять только изменённые элементы страницы;
  \item Применение функций подключения обеспечивает современное управление состоянием и побочными эффектами.
\end{enumerate}


Преимущества для образовательных платформ:
\begin{enumerate}
  \item Быстрая разработка за счёт декларативности и компонентного подхода;
  \item Большое сообщество и развитая экосистема;
  \item Поддержка SSR и SSG рендерингов при использовании фреймворка Next.js;
  \item Простая интеграция с библиотеками и сторонними сервисами.
\end{enumerate}

Ограничения:
\begin{enumerate}
  \item Отсутствие встроенной архитектуры требует выбора и настройки дополнительных инструментов;
  \item Более низкий порог входа может привести к «разнообразию» архитектурных подходов в команде;
  \item Отсутствует маршрутизация и SSR рендеринга.
\end{enumerate}

\subsubsection{Веб-фреймворк Angular}
Angular --- полнофункциональный фреймворк для создания больших приложений~\cite{angular_overview}. В отличие от библиотеки React, он требует строгого следования архитектурным правилам, что особенно ценно при командной разработке.

Одна из ключевых возможностей фреймворка Angular --- автоматическое обновление данных в обоих направлениях между моделью и представлением. Для управления зависимостями между компонентами фреймворк использует специальные сервисы~\cite{angular_dependency_injection}. Разработчики могут быстро создавать элементы приложения через командную строку благодаря встроенным инструментам. Полная поддержка языка программирования TypeScript обеспечивает строгую типизацию на всех уровнях приложения.

При использовании фреймворка Angular обеспечивает чёткую структуру проекта, что упрощает совместную работу. Встроенные механизмы проверки данных в формах ускоряют разработку. Готовые решения для маршрутизации и HTTP-запросов позволяют сразу перейти к реализации бизнес-логики.

Однако фреймворк Angular имеет высокий порог входа, поэтому новичкам придется нелегко. Другим ограничением является размер итогового приложения: даже минимальная сборка имеет размер около 500 КБ, что влияет на скорость загрузки. Фреймворк также имеет жёсткие требования к структуре приложения, оставляя мало свободы для отклонений от официальных рекомендаций.

\subsubsection{Веб-фреймворк Vue.js}
Vue.js --- гибкий фреймворк, объединяющий лучшие идеи библиотек React и Angular~\cite{vuejs_guide}. Его архитектура идеально подходит как для быстрого прототипирования, так и для проектов средней сложности.

Основу Vue.js составляет система автоматического обновления интерфейса при изменении данных. Каждый компонент реализуется в одном файле, где объединены HTML-шаблон, логика на языке программирования JavaScript и стили на языке разметки CSS. Для создания анимаций предусмотрены специальные встроенные директивы.

Фреймворк Vue.js выгоден в проектах благодаря понятной документации с интерактивными примерами. Низкий порог вхождения позволяет новичкам быстро освоиться.

К ограничениям Vue.js относится меньший размер сообщества по сравнению с библиотеками React и Angular, что может замедлить поиск решений сложных задач. Без использования фреймворка Nuxt.js возможности серверного рендеринга существенно ограничены. Также наблюдается дефицит готовых библиотек компонентов интерфейса по сравнению с другими фреймворками.

\subsubsection{Сравнительный анализ фреймворков}

На основе сравнения характеристик трёх популярных JavaScript-фреймворков (см. таблицу~\ref{tab:framework-comparison}) можно сделать следующие выводы: библиотека React с фреймворком Next.js демонстрирует высокую производительность и даёт гибкую архитектуру, а встроенная поддержка SSR/SSG рендера и SEO-оптимизация делают этот стек идеальным выбором для масштабируемых образовательных приложений. Фреймворк Angular, с другой стороны, благодаря строгой типизации и продуманной структуре, подходит для крупных систем, где важны единообразие и безопасность приложения. Фреймворк Vue.js сочетает в себе простоту освоения и возможность расширения экосистемы, что отлично для быстрого запуска MVP-продуктов (продуктов с минимальным необходимым функционалом) и небольших команд.

\begin{table}[h]
  \small
  \centering
  \caption{Сравнение характеристик фреймворков}
  \label{tab:framework-comparison}
  \begin{tabular}{|l|c|c|c|}
  	\hline
  	\textbf{Параметр}     & React и Next.js &   Angular   &  Vue.js  \\ \hline
  	Кривая обучения       &     Средняя     &   Высокая   & Средняя  \\ \hline
  	Сообщество            &     Крупное     &   Крупное   & Растущее \\ \hline
  	Производительность    &     Высокая     &   Средняя   & Высокая  \\ \hline
  	Гибкость архитектуры  &     Высокая     & Минимальная & Средняя  \\ \hline
  	Поддержка SSR         &   Встроенная    & Встроенная  & Nuxt.js  \\ \hline
  	Поддержка TypeScript  &       Да        &     Да      &    Да    \\ \hline
  	Готовая маршрутизация &       Да        &     Да      &    Да    \\ \hline
  \end{tabular}
\end{table}

\subsubsection*{Фреймворк Next.js}

Фреймворк содержит в себе серверный рендеринг и «гидратацию» клиентского приложения, обеспечивая быструю и плавную работу приложений. Благодаря гидратации браузер получает только необходимый на текущий момент минимальный объём текста программы языка программирования JavaScript, а по мере навигации и взаимодействия фреймворк автоматически подгружает дополнительные скрипты, расширяя уже отрендеренный контент. Это снижает время первого отображения страницы и ускоряет переходы между разделами, что особенно важно для крупных проектов с большими бандлами.

В документации~\cite{nextjs_ssr} выделяют несколько режимов серверного рендеринга:
\begin{enumerate}
  \item Классический серверный рендеринг SSR предполагает, что HTML-страница полностью генерируется на сервере при каждом запросе и отправляется клиенту. Пользователь сразу видит готовый контент без ожидания выполнения JavaScript-логики.
  \item Режим SSG (Static Site Generation) использует статическую генерацию страниц на этапе билда проекта. Все HTML-файлы подготавливаются заранее и хранятся на сервере, что позволяет отдавать их мгновенно и без лишних вычислений~\cite{nextjs_ssg_isr}.
  \item Подход ISR (Incremental Static Regeneration) представляет собой расширение SSG рендеринга. Он позволяет автоматически пересобирать отдельные страницы через заданные интервалы времени, сохраняя преимущества статической отдачи и обеспечивая актуальность контента~\cite{nextjs_ssg_isr}.
\end{enumerate}


Такой многообразный набор инструментов делает фреймворк Next.js крайне гибким: разработчики могут подобрать оптимальный способ рендеринга для каждой страницы --- от полностью статических лендингов до динамических разделов с актуальными данными. В результате ваше приложение получает высокую производительность, хорошую индексацию поисковиками и комфортный пользовательский опыт без избыточной передачи данных.

\subsubsection*{Библиотека Socket.IO}

Библиотека Socket.IO с открытым исходным кодом предназначена для реализации двустороннего взаимодействия между клиентом и сервером в режиме реального времени. В соответствии с документацией~\cite{socketio_docs} особенностью данной технологии является использование собственного настройку поверх WebSocket протокола с возможностью автоматического переключения на альтернативные методы связи при отсутствии поддержки WebSocket протокола.

Преимущества использования библиотеки Socket.IO:
\begin{enumerate}
  \item Обеспечивает гибкость за счёт полного контроля над архитектурой соединения, включая маршрутизацию сообщений, обработку событий, систему комнат и пространств имён;
  \item Позволяет достигать масштабируемости благодаря поддержке кластеризации и горизонтального масштабирования с использованием адаптеров из библиотеки Redis;
  \item Обеспечивает совместимость с средой Node.js, благодаря чему легко интегрируется в стек на его основе и упрощает реализацию единой инфраструктуры;
  \item Достигает высокой производительности за счёт низкой задержки при передаче сообщений через постоянное соединение между клиентом и сервером;
  \item Поддерживает интеграцию с языком программирования Python посредством библиотеки \textit{python-socketio}, которая предоставляет аналогичные возможности для реализации чатов и двустороннего общения между клиентом и сервером.
\end{enumerate}


Из недостатков библиотеки можно выделить следующее:
\begin{enumerate}
  \item Необходимость разработки и поддержки собственной серверной инфраструктуры;
  \item Повышенная сложность при масштабировании без использования внешних инструментов;
  \item Отсутствие встроенной панели мониторинга или аналитики соединений.
\end{enumerate}

\subsubsection*{Сервис обмена событиями в реальном времени Pusher}

Pusher — это облачная платформа, предоставляющая инструменты для реализации push-уведомлений и двусторонней передачи данных в реальном времени~\cite{pusher_docs}. В отличие от библиотеки Socket.IO, платформа Pusher представляет собой менеджер, абстрагирующий низкоуровневые детали инфраструктуры.

Преимущества использования платформы Pusher:
\begin{enumerate}
  \item Интеграция осуществляется с минимальными усилиями благодаря SDK-инструментам и готовым клиентским библиотекам, которые позволяют быстро настроить соединение и передавать события;
  \item Масштабируемость достигается на уровне платформы и не требует участия разработчика;
  \item Надёжность обеспечивается за счёт устойчивой облачной инфраструктуры с балансировкой нагрузки;
  \item Аналитика и мониторинг доступны через панель управления, где отображаются данные о соединениях, событиях и каналах.
\end{enumerate}

Ограничения:
\begin{enumerate}
  \item Бесплатный тариф ограничен по числу соединений и событий, что делает использование невыгодным при росте нагрузки;
  \item Использование зависит от стороннего сервиса, что создаёт потенциальные риски, связанные с отказоустойчивостью внешнего провайдера;
  \item Возможности изменения ограничены, так как структура событий и поведение зависят от особенностей платформы.
\end{enumerate}

\subsubsection*{Двунаправленный обмен сообщениями в языке программирования JavaScript}

WebSocket~--- это сетевой протокол, предназначенный для организации постоянного двунаправленного соединения между клиентом и сервером, что позволяет обмениваться сообщениями в реальном времени. Язык программирования JavaScript предоставляет встроенный класс \textit{WebSocket} для организации двустороннего обмена данными между клиентом и сервером~\cite{mdn_websocket_api}. Этот класс реализует базовую функциональность протокола WebSocket, предоставляя разработчикам простой способ обмена данными в реальном времени без необходимости использовать сторонние библиотеки. Однако, несмотря на свою доступность, использование класса \textit{WebSocket} требует значительных усилий для реализации различных важных аспектов взаимодействия.

К примеру, при использовании класса \textit{WebSocket} разработчик должен самостоятельно реализовать:
\begin{enumerate}
  \item Переподключение сокета при его падении;
  \item Буферизацию сообщений в случае разрыва соединения;
  \item Обработку таймаутов и ошибок;
  \item Поддержку различных сред Node.js и браузера;
  \item Масштабирование на сервере.
\end{enumerate}

Таким образом, несмотря на его доступность и гибкость, использование класса \textit{WebSocket} требует написания значительного объёма дополнительной логики. Это делает его менее удобным для быстрого внедрения в проект, особенно в случае масштабируемых приложений.

С учётом всех этих факторов было принято решение отказаться от использования низкоуровневого класса \textit{WebSocket} в пользу более высокоуровневых решений, предоставляемых библиотекой \textit{Socket.IO} или платформой \textit{Pusher}, которые предоставляют необходимую функциональность и обрабатывают множество нюансов «из коробки», позволяя сосредоточиться на бизнес-логике приложения.


\subsubsection*{Сравнение и выбор технологии для чатов}

При сравнении библиотеки Socket.IO и платформы Pusher необходимо учитывать как технические, так и организационные аспекты. В таблице \ref{tab:chat-comparison} представлено краткое сопоставление ключевых параметров:

\begin{table}[h]
  \centering
  \caption{Сравнение технологий для реализации чатов}
  \small
  \label{tab:chat-comparison}
  \begin{tabular}{|l|p{5cm}|p{5cm}|}
  	\hline
  	\textbf{Критерий}  & \textbf{Socket.IO}          & \textbf{Pusher}                \\ \hline
  	Тип решения        & Open-source библиотека      & Облачный менеджер              \\ \hline
  	Контроль над       & Полный                      & Ограниченный                   \\
  	архитектурой       &                             &                                \\ \hline
  	Поддержка          & Через Redis и кластеризацию & Встроенная на уровне платформы \\ \hline
  	Простота настройки & Средняя (требует сервера)   & Высокая                        \\ \hline
  	Затраты на         & Бесплатно                   & Платная модель                 \\ \hline
  	Интеграция с       & Нативная                    & Через SDK                      \\
  	Node.js            &                             &                                \\ \hline
  	Надёжность         & Высокая                     & Высокая                        \\ \hline
  	Кастомизация       & Да                          & Нет                            \\ \hline
  \end{tabular}
\end{table}

С учётом специфики проекта — ограниченного бюджета, необходимости полной кастомизации и тесной интеграции с Node.js-сервером — наилучшим выбором является использование библиотеки Socket.IO. Данная библиотека предоставляет все необходимые механизмы для реализации масштабируемой и надёжной системы общения, при этом позволяя оптимизировать производительность без привлечения сторонних сервисов.

Более того, благодаря открытому исходному тексту библиотеки Socket.IO не ограничивает разработчика в выборе архитектурных решений, а также обеспечивает возможность расширения функционала в будущем. В условиях ограниченных ресурсов образовательной платформы такой подход оказывается наиболее целесообразным.

\subsubsection*{Библиотека аутентификации Auth.js}

Auth.js — это библиотека для реализации аутентификации и авторизации в веб-приложениях. Она является официальным решением, рекомендуемым и поддерживаемым фреймворком Next.js, что гарантирует хорошую интеграцию и поддержку всех необходимых функций. Библиотека позволяет легко подключать сторонние провайдеры аутентификации, такие как Google, Facebook и другие (см.~\cite{nextauth_docs}), а также реализовывать собственную аутентификацию с использованием базы данных. Библиотека Auth.js обеспечивает надёжную защиту пользовательских данных, управление сессиями, работу с токенами и предоставляет удобные интерфейс для быстрой настройки. Это решение упрощает реализацию всех ключевых механизмов безопасности, освобождая разработчиков от необходимости погружаться в тонкости реализации.  

\subsubsection*{Библиотека управления состоянием приложения Redux}

Redux — это библиотека для управления состоянием в приложениях, основанных на библиотеке React ~\cite{redux_docs}. Она используется для централизованного хранения состояния приложения, что облегчает обмен данными между компонентами и упрощает их взаимодействие. Библиотека Redux помогает избежать проблемы передачи данных через большое количество вложенных компонентов в больших приложениях, когда передача данных через множество вложенных компонентов становится сложной. Хоть библиотека Redux часто используется в более сложных приложениях, в данном проекте его роль заключается в том, чтобы сделать взаимодействие между компонентами более организованным и простым.

