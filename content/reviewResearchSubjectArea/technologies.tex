\subsection{Технологии разработки клиентской части приложения}

Для реализации клиентской части платформы выбраны современные инструменты, обеспечивающие модульность, производительность, типизацию и масштабируемость интерфейса.

\subsubsection{Язык программирования TypeScript}

JavaScript является одним из самых популярных языков программирования для веб-разработки. Он широко используется для создания динамичных веб-страниц и приложений, поскольку позволяет работать с элементами DOM-дерева (представление HTML-документа в виде дерева тегов), асинхронно загружать данные и обеспечивать интерактивность пользовательских интерфейсов. Однако JavaScript имеет важный недостаток — отсутствие статической типизации. Это означает, что переменные и функции не привязываются к определённым типам данных, что может привести к ошибкам на этапе выполнения, которые трудно обнаружить в процессе разработки. Особенно это может быть проблемой в крупных приложениях, где сложно отслеживать все возможные типы данных и их изменения.

Для устранения этих проблем был разработан язык TypeScript, являющийся надмножеством JavaScript. TypeScript добавляет в JavaScript статическую типизацию, что позволяет разработчикам явно указывать типы данных для переменных и функций. Это значительно снижает вероятность ошибок и улучшает поддержку приложения в будущем. Благодаря строгой типизации TypeScript помогает предотвращать баги, связанные с динамическими типами в JavaScript, и улучшает автозаполнение в редакторах текста программы. TypeScript распространяется как библиотека, которую можно интегрировать в проекты на JavaScript, обеспечивая совместимость с существующим приложением и позволяя постепенно внедрять типизацию без необходимости переписывать весь проект. Это особенно важно в крупных и масштабируемых приложениях, где несколько разработчиков работают с общими компонентами, и типизация помогает поддерживать консистентность текста программы на протяжении всего проекта. Для получения большей информации смотрите документацию~\cite{typescript_handbook}.

\subsubsection{Библиотека React}

React — библиотека для построения пользовательских интерфейсов, разработанная Facebook (см. документацию~\cite{react_getting_started}). Она широко используется в веб-разработке благодаря своей простоте, гибкости и высокой производительности. React обеспечивает декларативный стиль программирования, при котором разработчик описывает, как должен выглядеть интерфейс при заданном состоянии, а библиотека самостоятельно обновляет DOM-дерево при изменениях. Это упрощает разработку сложных и динамичных интерфейсов.

Можно выделить следующие ключевые особенности
\begin{enumerate}
  \item Приложение разбивается на переиспользуемые и изолированные компоненты, что отражает компонентный подход;
  \item Синтаксис JSX объединяет JavaScript и разметку, упрощая написание пользовательского интерфейса;
  \item Использование Virtual DOM позволяет эффективно обновлять только изменённые элементы страницы;
  \item Применение Hooks API обеспечивает современное управление состоянием и побочными эффектами.
\end{enumerate}


Преимущества для образовательных платформ:
\begin{enumerate}
  \item Быстрая разработка за счёт декларативности и компонентного подхода;
  \item Большое сообщество и развитая экосистема (Next.js, Redux, React Query и др.);
  \item Поддержка SSR и SSG при использовании Next.js;
  \item Простая интеграция с библиотеками и сторонними сервисами.
\end{enumerate}

Ограничения:
\begin{enumerate}
  \item Отсутствие встроенной архитектуры требует выбора и настройки дополнительных инструментов;
  \item Более низкий порог входа может привести к «разнообразию» архитектурных подходов в команде;
  \item Отсутствует маршрутизация, SSR и API.
\end{enumerate}

\subsubsection{Веб-фреймворк Angular}
Angular --- полнофункциональный фреймворк для создания больших приложений~\cite{angular_overview}. В отличие от React, он требует строгого следования архитектурным правилам, что особенно ценно при командной разработке.

Одна из ключевых возможностей Angular --- автоматическое обновление данных в обоих направлениях между моделью и представлением. Для управления зависимостями между компонентами фреймворк использует специальные сервисы~\cite{angular_dependency_injection}. Разработчики могут быстро создавать элементы приложения через командную строку благодаря встроенным инструментам. Полная поддержка TypeScript обеспечивает строгую типизацию на всех уровнях приложения.

При использовании Angular обеспечивает чёткую структуру проекта, что упрощает совместную работу. Встроенные механизмы проверки данных в формах ускоряют разработку. Готовые решения для маршрутизации и HTTP-запросов позволяют сразу перейти к реализации бизнес-логики.

Однако Angular имеет высокий порог входа, поэтому новичкам придется нелегко. Другим ограничением является размер итогового приложения: даже минимальная сборка занимает около 500 КБ, что влияет на скорость загрузки. Фреймворк также имеет жёсткие требования к структуре приложения, оставляя мало свободы для отклонений от официальных рекомендаций.

\subsubsection{Веб-фреймворк Vue.js}
Vue.js --- гибкий фреймворк, объединяющий лучшие идеи React и Angular~\cite{vuejs_guide}. Его архитектура идеально подходит как для быстрого прототипирования, так и для проектов средней сложности.

Основу Vue.js составляет система автоматического обновления интерфейса при изменении данных. Компоненты реализуются в едином файле, содержащий HTML-шаблон, JavaScript-логику и CSS-стили. Для создания анимаций предусмотрены специальные встроенные директивы.

В проектах Vue.js выгоден благодаря исключительно понятной документации с интерактивными примерами. Низкий порог вхождения позволяет новичкам быстро освоить основы.

К ограничениям Vue.js относится меньший размер сообщества по сравнению с React и Angular, что может замедлить поиск решений сложных задач. Без использования фреймворка Nuxt.js возможности серверного рендеринга (SSR) существенно ограничены. Также наблюдается дефицит готовых библиотек компонентов интерфейса по сравнению с другими фреймворками.

\subsubsection{Сравнительный анализ фреймворков}

На основе сравнения характеристик трёх популярных JavaScript-фреймворков (см. таблицу~\ref{tab:framework-comparison}) можно сделать следующие выводы: React с Next.js демонстрирует высокую производительность и даёт гибкую архитектуру, а встроенная поддержка SSR/SSG рендера и SEO-оптимизация делают этот стек идеальным выбором для масштабируемых образовательных приложений. Angular, с другой стороны, благодаря строгой типизации и продуманной структуре, подходит для крупных систем, где важны единообразие и безопасность приложения. Vue.js сочетает в себе простоту освоения и возможность расширения экосистемы, что отлично для быстрого запуска MVP и небольших команд.

\begin{table}[h]
  \small
  \centering
  \caption{Сравнение характеристик фреймворков}
  \label{tab:framework-comparison}
  \begin{tabular}{|l|c|c|c|}
    \hline
    \textbf{Параметр}         & React + Next.js       & Angular       & Vue.js   \\ \hline
    Кривая обучения           & Средняя               & Высокая       & Средняя  \\ \hline
    Сообщество                & Крупное               & Крупное       & Растущее \\ \hline
    Производительность        & Высокая               & Средняя       & Высокая  \\ \hline
    Гибкость архитектуры      & Высокая               & Минимальная   & Средняя  \\ \hline
    Поддержка SSR             & Встроенная (Next.js)  & Встроенная    & Nuxt.js  \\ \hline
    Поддержка TypeScript      & Да                    & Да            & Да       \\ \hline
    Готовая маршрутизация     & Да (Next.js)          & Да            & Да (Vue Router) \\ \hline
  \end{tabular}
\end{table}

\subsubsection*{Фреймворк Next.js}

Фреймворк для React объединяет в себе серверный рендеринг и «гидратацию» клиентского приложения, обеспечивая быструю и плавную работу приложений. Благодаря гидратации браузеру отправляется только необходимый на текущий момент минимальный объём JavaScript, а по мере навигации и взаимодействия фреймворк автоматически подгружает дополнительные скрипты, расширяя уже отрендеренный контент. Это снижает время первого отображения страницы и ускоряет переходы между разделами, что особенно важно для крупных проектов с большими бандлами.

В документации~\cite{nextjs_ssr} выделяют несколько режимов серверного рендеринга:
\begin{enumerate}
  \item Классический серверный рендеринг SSR (Server-Side Rendering) предполагает, что HTML-страница полностью генерируется на сервере при каждом запросе и отправляется клиенту. Пользователь сразу видит готовый контент без ожидания выполнения JavaScript.
  \item Режим SSG (Static Site Generation) использует статическую генерацию страниц на этапе билда проекта. Все HTML-файлы подготавливаются заранее и хранятся на сервере, что позволяет отдавать их мгновенно и без лишних вычислений~\cite{nextjs_ssg_isr}.
  \item Подход ISR (Incremental Static Regeneration) представляет собой расширение SSG. Он позволяет автоматически пересобирать отдельные страницы через заданные интервалы времени, сохраняя преимущества статической отдачи и обеспечивая актуальность контента~\cite{nextjs_ssg_isr}.
\end{enumerate}


Такой многообразный набор инструментов делает Next.js крайне гибким: разработчики могут подобрать оптимальный способ рендеринга для каждой страницы --- от полностью статических лендингов до динамических разделов с актуальными данными. В результате ваше приложение получает высокую производительность, хорошую индексацию поисковиками и комфортный пользовательский опыт без избыточной передачи данных.

\subsubsection*{Библиотека Socket.IO}

JavaScript-библиотека Socket.IO с открытым исходным кодом предназначена для реализации двустороннего взаимодействия между клиентом и сервером в режиме реального времени. В соответствии с документацией~\cite{socketio_docs} особенностью данной технологии является использование собственного протокола поверх WebSocket с возможностью автоматического переключения на альтернативные методы связи (long polling и др.) при отсутствии поддержки WebSocket.

Преимущества использования Socket.IO:
\begin{enumerate}
  \item Обеспечивает гибкость за счёт полного контроля над архитектурой соединения, включая маршрутизацию сообщений, обработку событий, систему комнат (rooms) и пространств имён (namespaces);
  \item Позволяет достигать масштабируемости благодаря поддержке кластеризации и горизонтального масштабирования с использованием Redis-адаптеров;
  \item Обеспечивает совместимость с Node.js, благодаря чему легко интегрируется в стек на его основе и упрощает реализацию единой инфраструктуры;
  \item Достигает высокой производительности за счёт низкой задержки при передаче сообщений через постоянное соединение между клиентом и сервером;
  \item Поддерживает интеграцию с Python посредством библиотеки \textit{python-socketio}, которая предоставляет аналогичные возможности для реализации чатов и двустороннего общения между клиентом и сервером.
\end{enumerate}


Из недостатков библиотеки можно выделить следующее:
\begin{enumerate}
  \item Необходимость разработки и поддержки собственной серверной инфраструктуры;
  \item Повышенная сложность при масштабировании без использования внешних инструментов (Redis, Kubernetes);
  \item Отсутствие встроенной панели мониторинга или аналитики соединений.
\end{enumerate}

\subsubsection*{Сервис обмена событиями в реальном времени Pusher}

Pusher — это облачная платформа, предоставляющая API и SDK для реализации push-уведомлений и двусторонней передачи данных в реальном времени~\cite{pusher_docs}. В отличие от Socket.IO, Pusher представляет собой managed-сервис, абстрагирующий низкоуровневые детали инфраструктуры.

Преимущества использования Pusher:
\begin{enumerate}
  \item Интеграция осуществляется с минимальными усилиями благодаря SDK и готовым клиентским библиотекам, которые позволяют быстро настроить соединение и передавать события;
  \item Масштабируемость достигается на уровне платформы и не требует участия разработчика;
  \item Надёжность обеспечивается за счёт устойчивой облачной инфраструктуры с балансировкой нагрузки;
  \item Аналитика и мониторинг доступны через панель управления, где отображаются данные о соединениях, событиях и каналах.
\end{enumerate}

Ограничения:
\begin{enumerate}
  \item Бесплатный тариф ограничен по числу соединений и событий, что делает использование невыгодным при росте нагрузки;
  \item Использование зависит от стороннего сервиса, что создаёт потенциальные риски, связанные с отказоустойчивостью внешнего провайдера;
  \item Возможности кастомизации ограничены, так как структура событий и поведение зависят от особенностей платформы.
\end{enumerate}

\subsubsection*{Двунаправленный обмен сообщениями в JavaScript}

WebSocket~--- это сетевой протокол, предназначенный для организации постоянного двунаправленного соединения между клиентом и сервером, что позволяет обмениваться сообщениями в реальном времени. JavaScript предоставляет встроенный класс \textit{WebSocket} для организации двустороннего обмена данными между клиентом и сервером~\cite{mdn_websocket_api}. Этот класс реализует базовую функциональность протокола WebSocket, предоставляя разработчикам простой способ обмена данными в реальном времени без необходимости использовать сторонние библиотеки. Однако, несмотря на свою доступность, использование \textit{WebSocket} требует значительных усилий для реализации различных важных аспектов взаимодействия.

К примеру, при использовании \textit{WebSocket} разработчик должен самостоятельно реализовать:
\begin{enumerate}
  \item Переподключение сокета при его падении;
  \item Буферизацию сообщений в случае разрыва соединения;
  \item Обработку таймаутов и ошибок;
  \item Поддержку различных сред (например, Node.js и браузер);
  \item Масштабирование на сервере.
\end{enumerate}

Таким образом, несмотря на его доступность и гибкость, использование \textit{WebSocket} требует написания значительного объёма дополнительной логики. Это делает его менее удобным для быстрого внедрения в проект, особенно в случае масштабируемых приложений.

С учётом всех этих факторов было принято решение отказаться от использования низкоуровневого \textit{WebSocket} в пользу более высокоуровневых решений, таких как \textit{Socket.IO} или \textit{Pusher}, которые предоставляют необходимую функциональность и обрабатывают множество нюансов «из коробки», позволяя сосредоточиться на бизнес-логике приложения.


\subsubsection*{Сравнение и выбор технологии для чатов}

При сравнении библиотек Socket.IO и Pusher необходимо учитывать как технические, так и организационные аспекты. В таблице \ref{tab:chat-comparison} представлено краткое сопоставление ключевых параметров:

\begin{table}[h]
  \centering
  \caption{Сравнение технологий для реализации чатов}
  \small
  \label{tab:chat-comparison}
  \begin{tabular}{|l|p{5cm}|p{5cm}|}
    \hline
    \textbf{Критерий} & \textbf{Socket.IO}               & \textbf{Pusher}                 \\ \hline
    Тип решения      & Open-source библиотека           & Облачный managed-сервис         \\ \hline
    Контроль над     & Полный                           & Ограниченный                    \\ 
    архитектурой     &                                  &                                 \\ \hline
    Поддержка        & Через Redis и кластеризацию      & Встроенная на уровне платформы  \\ \hline
    Простота настройки & Средняя (требует сервера)      & Высокая (SDK)                   \\ \hline
    Затраты на       & Бесплатно                        & Платная модель                  \\ \hline
    Интеграция с     & Нативная                         & Через SDK                       \\ 
    Node.js          &                                  &                                 \\ \hline
    Надёжность       & Высокая                          & Высокая                         \\ \hline
    Кастомизация     & Да                               & Нет                             \\ \hline
  \end{tabular}
\end{table}

С учётом специфики проекта — ограниченного бюджета, необходимости полной кастомизации и тесной интеграции с Node.js-сервером — наилучшим выбором является использование Socket.IO. Данная библиотека предоставляет все необходимые механизмы для реализации масштабируемой и надёжной чат-системы, при этом позволяя оптимизировать производительность без привлечения сторонних сервисов.

Более того, благодаря открытому коду Socket.IO не ограничивает разработчика в выборе архитектурных решений, а также обеспечивает возможность расширения функционала в будущем. В условиях ограниченных ресурсов образовательной платформы такой подход оказывается наиболее целесообразным.

\subsubsection*{Библиотека аутентификации Auth.js}

Auth.js — это библиотека для реализации аутентификации и авторизации в веб-приложениях. Она является официальным решением, рекомендуемым и поддерживаемым фреймворком Next.js, что гарантирует хорошую интеграцию и поддержку всех необходимых функций. Библиотека позволяет легко подключать сторонние провайдеры аутентификации, такие как Google, Facebook и другие (см.~\cite{nextauth_docs}), а также реализовывать собственную аутентификацию с использованием базы данных. Auth.js обеспечивает надёжную защиту пользовательских данных, управление сессиями, работу с токенами и предоставляет удобные API для быстрой настройки. Это решение упрощает реализацию всех ключевых механизмов безопасности, освобождая разработчиков от необходимости погружаться в тонкости реализации.  

\subsubsection*{Библиотека управления состоянием приложения Redux}

Redux — это библиотека для управления состоянием в приложениях, основанных на React ~\cite{redux_docs}. Она используется для централизованного хранения состояния приложения, что облегчает обмен данными между компонентами и упрощает их взаимодействие. Redux помогает избежать проблемы передачи данных через большое количество вложенных компонентов в больших приложениях, когда передача данных через множество вложенных компонентов становится сложной. Хотя Redux часто используется в более сложных приложениях, в данном проекте его роль заключается в том, чтобы сделать взаимодействие между компонентами более организованным и простым.

